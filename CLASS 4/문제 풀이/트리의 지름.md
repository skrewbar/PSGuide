# 문제
![[g4.svg|tier]] [트리의 지름](https://www.acmicpc.net/problem/1967)
# 풀이
루트에서 가장 먼 정점 $u$를 찾습니다.

$u$에서 가장 먼 정점까지의 거리가 트리의 지름이 됩니다.
## 증명
트리의 지름이 루트를 지난다고 하면 자명하게 성립합니다.

트리의 지름이 어떤 서브트리에 있다고 생각해 봅시다.

두 정점 $u$, $v$ 사이의 거리를 $d(u, v)$라 합시다.

지름을 이루는 경로는 리프 노드에서 시작하여 깊이가 얕아졌다가 다시 리프 노드로 향하는 경로일 것입니다. 이때 시작하는 리프 노드를 $a$, 깊이가 가장 얕은 노드를 $b$, 마지막 리프 노드를 $c$라 합시다.

이때 일반성을 잃지 않고 $d(a, b) \ge d(b, c)$라 합시다.

해당 경로가 지름이라는 뜻은 $a$를 제외한 모든 리프 노드 $l$에 대해 $d(b, a) \ge d(b, l)$임을 뜻합니다.

$d(b, l)$를 이루는 경로에서 깊이가 가장 얕은 노드를 $i$라 하면 $d(b, l) = d(b, i) + d(i, l)$입니다. 이때 $i$의 깊이는 $b$보다 얕거나 같습니다.

루트 $r$에서의 거리를 비교하면 $d(r, a) = d(r, b) + d(b, a)$이고 $d(r, l) = d(r, i) + d(i, l)$입니다.

그런데 $d(b, i) + d(i, l) \le d(b, a)$이고 $b$가 $r$보다 깊어서 $d(r, b) \ge d(r, i)$이므로 $d(r, a) \ge d(r, l)$입니다.

따라서 루트에서 찾는 가장 먼 정점은 항상 $a$이고, 알고리즘이 항상 답을 찾음을 알 수 있습니다.
# 코드
## Python
```python
from collections import deque

n = int(input())
INF = 1 << 30

adj: list[list[tuple[int, int]]] = [[] for _ in range(n + 1)]

for _ in range(n - 1):
    u, v, w = map(int, input().split())

    adj[u].append((v, w))
    adj[v].append((u, w))


def findDistFrom(root: int) -> list[int]:
    queue = deque([root])

    dist = [INF] * (n + 1)
    dist[root] = 0

    while queue:
        now = queue.popleft()

        for nxt, weight in adj[now]:
            if dist[nxt] != INF:
                continue

            dist[nxt] = dist[now] + weight
            queue.append(nxt)

    return dist


dist = findDistFrom(1)
farthest = max(range(1, n + 1), key=lambda x: dist[x])

print(max(findDistFrom(farthest)[1:]))
```
## C++
```cpp
#include <bits/stdc++.h>
using namespace std;

constexpr int INF = INT_MAX;

int n;
vector<vector<pair<int, int>>> adj;

vector<int> findDistFrom(int root) {
    queue<int> q;
    q.push(root);

    vector<int> dist(n + 1, INF);
    dist[root] = 0;

    while (not q.empty()) {
        int now = q.front();
        q.pop();

        for (auto [nxt, weight] : adj[now]) {
            if (dist[nxt] != INF)
                continue;

            dist[nxt] = dist[now] + weight;
            q.push(nxt);
        }
    }

    return dist;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    cin >> n;
    adj.resize(n + 1);

    for (int i = 0; i < n - 1; i++) {
        int u, v, w;
        cin >> u >> v >> w;

        adj[u].emplace_back(v, w);
        adj[v].emplace_back(u, w);
    }

    vector<int> dist = findDistFrom(1);
    int farthest = 1;
    for (int i = 2; i <= n; i++) {
        if (dist[i] > dist[farthest])
            farthest = i;
    }

    dist = findDistFrom(farthest);
    int ans = 0;
    for (int i = 1; i <= n; i++)
        ans = max(ans, dist[i]);

    cout << ans;

    return 0;
}
```
## Java
```java
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.Queue;
import java.util.StringTokenizer;

public class Main {
    static final int INF = Integer.MAX_VALUE;
    static int n;
    static ArrayList<ArrayList<Edge>> adj = new ArrayList<>();

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

        n = Integer.parseInt(br.readLine());
        for (int i = 0; i <= n; i++)
            adj.add(new ArrayList<>());

        for (int i = 0; i < n - 1; i++) {
            StringTokenizer tk = new StringTokenizer(br.readLine());
            int u = Integer.parseInt(tk.nextToken()), v = Integer.parseInt(tk.nextToken()),
                    w = Integer.parseInt(tk.nextToken());

            adj.get(u).add(new Edge(v, w));
            adj.get(v).add(new Edge(u, w));
        }

        int[] dist = findDistFrom(1);
        int farthest = 1;
        for (int i = 2; i <= n; i++) {
            if (dist[i] > dist[farthest])
                farthest = i;
        }

        dist = findDistFrom(farthest);
        int ans = 0;
        for (int i = 1; i <= n; i++)
            ans = Math.max(ans, dist[i]);

        bw.write(ans + "");
        bw.close();
    }

    public static int[] findDistFrom(int root) {
        int[] dist = new int[n + 1];
        Arrays.fill(dist, INF);
        dist[root] = 0;

        Queue<Integer> q = new LinkedList<>();
        q.add(root);
        while (!q.isEmpty()) {
            int now = q.poll();

            for (Edge e : adj.get(now)) {
                if (dist[e.node] != INF)
                    continue;

                dist[e.node] = dist[now] + e.weight;
                q.add(e.node);
            }
        }

        return dist;
    }
}

class Edge {
    int node, weight;

    public Edge(int node, int weight) {
        this.node = node;
        this.weight = weight;
    }
}
```