# 문제
![[g4.svg|tier]] [최단 경로](https://www.acmicpc.net/problem/1753)
# 풀이
데이크스트라 알고리즘으로 해결할 수 있습니다.
# 코드
## Python
```python
import heapq

INF = 1 << 30

V, E = map(int, input().split())

adj = [[] for _ in range(V + 1)]

K = int(input())

for _ in range(E):
    u, v, w = map(int, input().split())
    adj[u].append((v, w))

dist = [INF] * (V + 1)
dist[K] = 0
queue = [(0, K)]

while queue:
    nowDist, now = heapq.heappop(queue)

    if nowDist > dist[now]:
        continue

    for nxt, edgeDist in adj[now]:
        if nowDist + edgeDist < dist[nxt]:
            dist[nxt] = nowDist + edgeDist
            heapq.heappush(queue, (dist[nxt], nxt))

for i in range(1, V + 1):
    print(dist[i] if dist[i] != INF else "INF")
```
## C++
```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int V, E;
    cin >> V >> E;

    vector<vector<pair<int, int>>> adj(V + 1);

    int K;
    cin >> K;

    for (int i = 0; i < E; i++) {
        int u, v, w;
        cin >> u >> v >> w;

        adj[u].emplace_back(v, w);
    }

    vector<int> dist(V + 1, INT_MAX);
    dist[K] = 0;

    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> pq;
    pq.emplace(dist[K], K);

    while (not pq.empty()) {
        auto [nowDist, now] = pq.top();
        pq.pop();

        if (nowDist > dist[now])
            continue;

        for (auto [next, edgeDist] : adj[now]) {
            if (nowDist + edgeDist < dist[next]) {
                dist[next] = nowDist + edgeDist;
                pq.emplace(dist[next], next);
            }
        }
    }

    for (int i = 1; i <= V; i++) {
        if (dist[i] != INT_MAX)
            cout << dist[i] << '\n';
        else
            cout << "INF\n";
    }

    return 0;
}
```
## Java
```java
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.PriorityQueue;
import java.util.StringTokenizer;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

        StringTokenizer tk = new StringTokenizer(br.readLine());
        int V = Integer.parseInt(tk.nextToken()), E = Integer.parseInt(tk.nextToken());
        int K = Integer.parseInt(br.readLine());

        ArrayList<ArrayList<Pair<Integer, Integer>>> adj = new ArrayList<>();
        for (int i = 0; i <= V; i++)
            adj.add(new ArrayList<>());

        for (int i = 0; i < E; i++) {
            tk = new StringTokenizer(br.readLine());

            int u = Integer.parseInt(tk.nextToken()),
                    v = Integer.parseInt(tk.nextToken()),
                    w = Integer.parseInt(tk.nextToken());

            adj.get(u).add(new Pair<>(v, w));
        }

        int dist[] = new int[V + 1];
        Arrays.fill(dist, Integer.MAX_VALUE);
        dist[K] = 0;

        PriorityQueue<Pair<Integer, Integer>> pq = new PriorityQueue<>();
        pq.add(new Pair<>(dist[K], K));

        while (!pq.isEmpty()) {
            int nowDist = pq.peek().first, now = pq.peek().second;
            pq.poll();

            if (nowDist > dist[now])
                continue;

            for (Pair<Integer, Integer> edge : adj.get(now)) {
                int next = edge.first, edgeDist = edge.second;

                if (nowDist + edgeDist < dist[next]) {
                    dist[next] = nowDist + edgeDist;
                    pq.add(new Pair<>(dist[next], next));
                }
            }
        }

        for (int i = 1; i <= V; i++) {
            if (dist[i] != Integer.MAX_VALUE)
                bw.write(dist[i] + "\n");
            else
                bw.write("INF\n");
        }

        bw.close();
    }
}

class Pair<T1 extends Comparable<T1>, T2 extends Comparable<T2>> implements Comparable<Pair<T1, T2>> {
    T1 first;
    T2 second;

    public Pair(T1 first, T2 second) {
        this.first = first;
        this.second = second;
    }

    @Override
    public int compareTo(Pair<T1, T2> p) {
        int cmp = this.first.compareTo(p.first);
        if (cmp != 0)
            return cmp;
        return this.second.compareTo(p.second);
    }
}
```